function sendBackThePostsToprint(callback)
{
    let request = new XMLHttpRequest();
    request.open("GET", "https://jsonplaceholder.typicode.com/posts");
    request.send();
    request.onload = () =>{
        //console.log(request.response);
        calback(request.response);
    }
}
function logPosts(posts)
{
    console.log(`posts are ${posts}`);

}
sendBackThePostsToprint(logPosts);


// Promises

// A promise is anect that represents something that will be available in the future in programming this something is values.

// Promises propose that instead of waiting for the value we want (eg the image download), we receive something that represents the value in that instant so that we can get on with our lives and then at some point go back and use the value generated by this promise

// Promises are based on time events and have some states that classify these events:

// Pending before the event happens;

// Settled/Resolved: after the event happens

// Fulfilled: when the promise returns the correct result:

// Rejected when the promise does not return the correct result.

// We can produce or consume promises. When we produce a promise. we create a new promise and send a result using that promise When we consume a promise, we use callback functions for the fulfilled and rejected states of that promise


const getEmployeeIds = new Promise((resolve, reject)=>{
    setTimeout(()=>{
        reject("rejected for learning purpose");
    },2000)
    setTimeout(()=>{
        console.log("trying to resolve after 5 seconds");
        resolve([2,3,4,5,6,7])
    },5000)
})

getEmployeeIds.then()
.then((idArray)=> {
console.log("promise resolved ids :", idArray)
})
.catch( error=>{
    console.log("promise rejected:", error)
})

function logPosts(posts)
{
    console.log(posts);
    console.log(`posts are ${posts}`);
}
fetch("https://jsonplaceholder.typicode.com/posts")
.then(response =>(response.json())).then(jsonValue=>logPosts(jsonValue));

// go through chain promises on your own

//Async/Await
// Async/await is another alternative for consuming promises, and it was implemented in ES8, or ES2017

// Asynciawait is a new way of writing promises that are based on asynchronous code but make asynchronous code look and behave more

let getEmployeeIds = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve([2,3,4,6,7])
    }, 5000)
});
let getEmployeeObject = (employeeId) => {
    return new Promise((resolve, reject) => {
        setTimeout((id)=> {
            const employee = {
                id: id,
                name: 'Bruno',
                role: 'UI Engineer'
            }
            resolve(employee)
        }, 2500, employeeId)
    })
}
async function getEmployee(){
    console.log("Inside getEmployee")
    const ids = await getEmployeeIds;
    console.log(ids);
    const employee = await getEmployeeObject(ids[1]);
    console.log(employee);
    return employee;
}
getEmployee().then( employee => {
    console.log(employee);
});
  
